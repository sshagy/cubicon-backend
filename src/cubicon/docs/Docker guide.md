### Docker
Докер это инструмент, который позволяет разработчикам, системными администраторам и другим специалистам деплоить их приложения в песочнице (которые называются контейнерами), для запуска на целевой операционной системе, например, Linux. Ключевое преимущество Докера в том, что он позволяет пользователям упаковать приложение со всеми его зависимостями в стандартизированный модуль для разработки. В отличие от виртуальных машин, контейнеры не создают такой дополнительной нагрузки, поэтому с ними можно использовать систему и ресурсы более эффективно.


###Container
Стандарт в индустрии на сегодняшний день — это использовать виртуальные машины для запуска приложений. Виртуальные машины запускают приложения внутри гостевой операционной системы, которая работает на виртуальном железе основной операционной системы сервера.

Виртуальные машины отлично подходят для полной изоляции процесса для приложения: почти никакие проблемы основной операционной системы не могут повлиять на софт гостевой ОС, и наоборот. Но за такую изоляцию приходится платить. Существует значительная вычислительная нагрузка, необходимая для виртуализации железа гостевой ОС.

Контейнеры используют другой подход: они предоставляют схожий с виртуальными машинами уровень изоляции, но благодаря правильному задействованию низкоуровневых механизмов основной операционной системы делают это с в разы меньшей нагрузкой.


###Быстрый старт: Docker Compose и Django

####1. Установите Doker
####2. Создайте Dockerfile
После установки Docker на ваш локальный компьютер, следующее, что нужно сделать, это создать Dockerfile. Dockerfile будет иметь набор инструкций о том, как Docker будет создавать образ контейнера для вашего приложения. Добавьте файл с именем Dockerfile без расширения в корневой каталог вашего проекта. 
Вот так:


    api/
        Dockerfile
        README.md
        requirements.txt    
        manage.py
        api/
            __init__.py
            settings.py
            urls.py
            wsgi.py
        music/
            migrations/
                __init__.py
            __init__.py
            admin.py
            apps.py
            models.py
            tests.py
            views.py
        venv/
      
      

Откройте Dockerfile в вашем редакторе и добавьте следующие строки;


    // Первая инструкция - на каком образе мы хотим основать наш контейнер
    // Мы используем официальную среду исполнения Python как родительский образ
  
    FROM python:3.6

    // Переменная окружения гарантирует, что вывод Python будет установлен прямо
    // в терминал без буферизации
    ENV PYTHONUNBUFFERED 1

    // создать корневую директорию для нашего проекта в контейнере
    RUN mkdir /music_service

    // Установить рабочий каталог в / music_service
    WORKDIR /music_service

    // Скопировать содержимое текущего каталога в контейнер в / music_service
    ADD . /music_service/

    // Установить все необходимые пакеты, указанные в файле requirements.txt
    RUN pip install -r requirements.txt

- Первая директива в Dockerfile, **FROM python: 3.6** сообщает Docker, на каком образе будет основан наш контейнер. Мы используем официальный образ Python от Dockerhub, который поставляется с настройками Python и Linux для вас, готов для использования в проекте Python.
- Следующая директива **ENV PYTHONUNBUFFERED 1** - это переменная окружения, которая указывает Docker не буферизировать вывод из Python в стандартный выходной буфер, а просто отправлять его прямо в терминал.
- Директива, которая начинается с **RUN**, инструктирует Docker выполнять любую команду, которая появляется после, как если бы вы выполняли ее в терминале на сервере.
В приведенном выше Dockerfile **RUN mkdir / music_service** указывает Docker создать папку в контейнере с именем music_service, которую мы будем использовать для хранения файлов нашего приложения.
- Директива, которая начинается с **WORKDIR**, устанавливает рабочий каталог, и все директивы, которые следуют в Dockerfile, будут выполняться в этом каталоге.
В приведенном выше Dockerfile я установил рабочий каталог music_service. Затем я добавляю все файлы в корневой каталог моего проекта, где Dockerfile находится в каталоге music_service в контейнере. 
- Директива **ADD** копирует файлы и каталоги из источника в место назначения, указанное в директиве.
- Последняя директива предписывает Docker запускать команду **pip** для установки требований, перечисленных в файле **requirements.txt**.
Теперь у нас есть Dockerfile для образа контейнера.

Содержимое **requirements.txt** может выглдеть следующим образом:

    Django==2.2
    djangorestframework==3.9.2
    django-filter==2.1.0
    drf-nested-routers==0.91

####3. Установите Docker Compose

***Compose*** - это инструмент для определения и запуска многоконтейнерных приложений Docker.
- Типичное развертывание API в производственной среде потребует от вас использования более одного контейнера. Вам понадобится отдельный контейнер для веб-сервера и отдельный контейнер для сервера базы данных. Docker compose поможет вам определить, как вы хотите, чтобы контейнеры были собраны и соединены, с помощью одной команды.
В Docker для Mac и Docker для Windows Docker compose поставляется с предустановленной версией, так что вы готовы к работе. В системах Linux вам нужно установить его напрямую.
Вы можете проверить, что он установлен, введя команду **docker-compose -vin** в вашем терминале. Вывод этой команды должен соответствовать версии Docker compose, установленной на вашем компьютере.
После установки на вашем компьютере docker compose, создайте файл **docker-compose.yml** в корневом каталоге, где находится **Dockerfile**.
Откройте файл **docker-compose.yml** и добавьте следующие строки:


    version: '3'
    services:
      web:
        build: .
        command: bash -c "python manage.py makemigrations && python manage.py migrate && python manage.py runserver 0.0.0.0:8000"
        container_name: music_service
        volumes:
          - .:/music_service
        ports:
    - "8000:8000"

- Первая строка в файле **docker-compose.yml** указывает, какую синтаксическую версию Docker вы хотите использовать.
- Далее мы определим сервис под названием **web**. 
- Директива **build** сообщается Docker compose для создания образа из файлов в корневом каталоге проекта. 
- Директива **command** - это команда по умолчанию, которая будет выполняться, когда Docker запустит образ контейнера.
- Директива **container_name** назначает имя для контейнера. Если имя не указано, Docker назначит контейнеру случайное имя. 
- Директива **volumes** монтирует корневой каталог проекта в папку контейнера music_service. По сути эта команда гарантирует, что когда я редактирую любой файл в папке проекта, папка контейнера обновляется немедленно.
- Наконец, мы открываем порт, по которому мы хотим получить доступ к контейнеру, используя директиву **ports**.

После этого вы можете собрать и запустить контейнер с помощью команды:  **docker-compose up**. Если ваша сборка прошла успешно, откройте браузер и получите доступ к API или приложению. Вы также можете попытаться получить доступ к администратору Django по адресу 127.0.0.1:8000/admin. Если вы видите страницу входа, значит ваш контейнер запущен и работает.

**P.S. Про запуск в Docker Compose Djando + PosgreSQL можно узнать здесь [->](https://docker.crank.ru/docs/docker-compose/quickstart-compose-and-django/)**

###Docker Compose команды:


    build              создает образ на основе Dockerfile.

    bundle             Создайет распределенный пакет приложений (DAB) из файла Compose.

    config             Показывет содержимое Compose файла

    create             Создает контейнеры для службы. Эта команда устарела. Вместо этого используйте команду `up` с` --no-start`.

    down               Останавливает контейнеры и удаляет контейнеры, сети, тома и образы, созданные up.
                       По умолчанию удаляются только следующие вещи:
                       Контейнеры для сервисов, определенных в файле Compose
                       Сети, определенные в разделе сетей файла Compose
                       Сеть по умолчанию, если она используется

    events             Потоковые контейнерные события для каждого контейнера в проекте.
                       С флагом --json объект json будет напечатан в формате:
                       {
                           "time": "2015-11-20T18:01:03.615550",
                           "type": "container",
                           "action": "create",
                           "id": "213cf7...5fc39a",
                           "service": "web",
                           "attributes": {
                               "name": "application_web_1",
                               "image": "alpine:edge"
                           }
                       }

    exec               Это эквивалент docker exec. С помощью этой подкоманды вы можете запускать произвольные команды в своих сервисах.

    help               Отображает справку и инструкции по использованию для команды.

    images             Список образов, используемых созданными контейнерами.

    kill               Принудительно останавливает запущенные контейнеры, отправляя сигнал SIGKILL.

    logs               Отображает вывод журнала из служб.

    pause              Поставит на паузу запущенный контейнер. Контейнер может быть запущен обратно с помощью docker-compose unpause.

    port               Печатает публичный порт.

    ps                 Список контейнеров.

    pull               Скачивает образ из регистра Docker и сохраняет его локально, не запускает скаченный образ.

    push               Переносит Ваш локальный образ в соответствующий реестр / репозиторий.

    restart            Перезапускает все остановленные и запущенные сервисы.
                       Если вы вносите изменения в конфигурацию docker-compose.yml, эти изменения не отражаются после выполнения этой команды.

    rm                 Удаляет остановленные сервисные контейнеры. По умолчанию анонимные тома, прикрепленные к контейнерам, не удаляются. 
                       Вы можете переопределить это с -v. Чтобы вывести список всех томов, используйте docker volume ls.
                       Выполнение команды без параметров также удаляет одноразовые контейнеры, созданные при запуске docker-compose up или docker-compose:

    run                Запускает одноразовую команду для службы. Например, следующая команда запускает веб-сервис и запускает bash в качестве своей команды.
                       docker-compose run web bash
                       Команды, которые вы используете при запуске run, стартуют в новых контейнерах с конфигурацией, включая тома, ссылки и другие. 
                       Однако есть два важных различия.
                       Во-первых, команда, переданная командой run, переопределяет команду, определенную в конфигурации. 
                       Например, если конфигурация веб-службы запускает bash, то docker-compose run web python app.py переопределяет его.
                       Второе отличие заключается в том, что команда docker-compose run не создает ни одного из портов, 
                       указанных в конфигурации. Это предотвращает конфликты портов с уже открытыми портами. 
                       Если вы хотите, чтобы порты службы создавались и отображались на хосте, укажите флаг --service-ports:
                       docker-compose run --service-ports web python manage.py shell

    scale              Примечание. Эта команда устарела. Вместо этого используйте команду up с флагом --scale. 
                       Помните, что использование флага --scale имеет некоторые тонкие отличия от команды scale, 
                       поскольку она включает в себя поведение команды up.
                       Устанавливает количество контейнеров для службы.
                       Числа указываются в качестве аргументов в форме service = num. 
                       Например: docker-compose scale web=2 worker=3

    start              Запускает существующие контейнеры для службы.

    stop               Останавливает работу контейнеров, не удаляя их. Они могут быть снова запущены командой docker-compose start.

    top                Отображает запущенные процессы.

    unpause            Запускает контейнеры стоящие на паузе.

    up                 Создает, пересоздает, запускает контейнер для службы.
                       Если они еще не запущены, эта команда также запускает любые связанные службы.
                       Команда docker-compose up агрегирует выходные данные каждого контейнера (по сути, запуская docker-compose logs -f). 
                       Когда команда завершается, все контейнеры останавливаются. 
                       Запуск docker-compose up -d запускает контейнеры в фоновом режиме и оставляет их работающими.
                       Если для службы существуют контейнеры, а конфигурация или образ службы были изменены после создания контейнера, 
                       docker-compose обрабатывает изменения, останавливая и воссоздавая контейнеры (сохраняя подключенные тома). 
                       Чтобы запретить Compose принимать изменения, используйте флаг --no-recreate.
                       Если вы хотите заставить Compose остановить и воссоздать все контейнеры, используйте флаг --force-recreate.
                       Если вы хотите заставить Compose остановить и воссоздать все контейнеры, используйте флаг --force-воссоздать.
                       Если процесс обнаруживает ошибку, код выхода для этой команды - 1.
                       Если процесс прерывается с помощью SIGINT (ctrl + C) или SIGTERM, контейнеры останавливаются, и код выхода равен 0.
                       Если SIGINT или SIGTERM отправляются снова во время этой фазы выключения, работающие контейнеры уничтожаются, и код выхода равен 2.



